package simplechat.server;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import ocsf.server.AbstractServer;import ocsf.server.ConnectionToClient;import simplechat.commands.CommandsManager;import simplechat.commands.exceptions.CommandException;import simplechat.commands.parser.IntArgument;import simplechat.commands.parser.StringArgument;import simplechat.commands.parser.StringWalker;import simplechat.common.ChatIF;import java.io.IOException;/** * This class overrides some of the methods in the abstract * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Laganière * @author François Bélanger * @author Paul Holden * @author Florent Hugouvieux * @version October 2020 */public class EchoServer extends AbstractServer{    /**     * The default port to listen on.     */    private static final String COMMAND_PREFIX = "#";    private final ChatIF serverUI;    private final ServerCommandsManager commandsManager = new ServerCommandsManager();    /**     * Constructs an instance of the echo server.     *     * @param port The port number to connect on.     */    public EchoServer(int port, ChatIF serverUI)    {        super(port);        this.serverUI = serverUI;    }    public void handleMessageFromUI(String message)    {        if (message.startsWith(COMMAND_PREFIX))        {            executeCommand(message);        }        else        {            String toSend = "Server MSG> " + message;            System.out.println(toSend);            sendToAllClients(toSend);        }    }    private void executeCommand(String message)    {        try        {            StringWalker walker = new StringWalker(message);            walker.next(COMMAND_PREFIX.length());            commandsManager.handleCommandLine(walker, this);        }        catch (CommandException commandException)        {            serverUI.errorMessage(commandException.getMessage());        }    }    public ChatIF getServerUI()    {        return serverUI;    }    /**     * This method handles any messages received from the simplechat.client.     *     * @param msg    The message received from the simplechat.client.     * @param client The connection from which the message originated.     */    @Override    public void handleMessageFromClient(Object msg, ConnectionToClient client)    {        serverUI.display("Message received: " + msg + " from " + client);        this.sendToAllClients(msg);    }    @Override    protected void serverStarted()    {        serverUI.display("Server listening for connections on port " + getPort());    }    @Override    protected void serverStopped()    {        serverUI.display("Server has stopped listening for connections.");    }    @Override    protected synchronized void clientDisconnected(ConnectionToClient client)    {        serverUI.display(client.getName() + " disconnected.");    }    @Override    protected void clientConnected(ConnectionToClient client)    {        serverUI.display(client.getName() + " connected.");        ;    }    @Override    protected synchronized void clientException(ConnectionToClient client, Throwable exception)    {        this.clientDisconnected(client);    }    public void quit()    {        try        {            this.close();        }        catch (IOException e)        {            e.printStackTrace();        }        System.exit(0);    }    public void disconnectClients()    {        Thread[] clientThreadList = getClientConnections();        for (Thread thread : clientThreadList)        {            try            {                ((ConnectionToClient) thread).close();            }            catch (Exception ex)            {                // Ignore all exceptions when closing clients.            }        }    }}